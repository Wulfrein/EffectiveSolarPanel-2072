// ППО-2024: Программа управления для автоматической солнечной панели. Школа №2072 //
// настройки:
#define DEBUG 1             // отладочная информация в СОМ-порт
#define GLOBALTIMER 50      // частота измерений
#define SP_MIN_VAL 700      // значение, при котором панель начнёт поворачиваться
#define MAXMINRATIO 1.3     // значение, при котором панель начнёт поворачиваться
#define MAXMINSETRATIO 1.2  // значение, при котором панель перестанет поворачиваться
#define SERVO_SPEED 25      // скорость сервопривода

// константы:
#define SOLAR_PAN_PIN A5  // пин солнечной панели
#define PHOTORES1_PIN A6  // пин фоторезистора 1
#define PHOTORES2_PIN A7  // пин фоторезистора 2
#define SERVO_SIG_PIN 3   // пин управления сервопривода

#include <Servo.h>  // подключаем библиотеку управления сервоприводами
Servo s1;           // создаем сервопривод

int s1_speed = 90;               // переменная для хранения скорости сервопривода
int SP_val, PhR1_val, PhR2_val;  // переменных для хранения данных с датчиков
int PhR_max, PhR_min;            // максимальное и минимальное показание
int rotdir = 1;                  // множитель направления вращения платформы (-1 либо +1)
float PhR_ratio = 1.0;           // отношение макс/мин освещения на фоторезисторах

void setup() {
  // режимы работы пинов
  pinMode(SOLAR_PAN_PIN, INPUT);
  pinMode(PHOTORES1_PIN, INPUT);
  pinMode(PHOTORES2_PIN, INPUT);

  // инициализация сервопривода
  pinMode(SERVO_SIG_PIN, OUTPUT);  // пин управления сервопривода, режим работы
  s1.attach(SERVO_SIG_PIN);        // ассоциируем сервопривод
  delay(1000);                     // ждём
  s1.write(90);                    // тест сервопривода: останавливаем
  delay(500);                      // тест сервопривода: ждём
  s1.write(90 - SERVO_SPEED);      // тест сервопривода: крутим в одну сторону
  delay(500);                      // тест сервопривода: ждём
  s1.write(90 + SERVO_SPEED);      // тест сервопривода: крутим в другую сторону
  delay(500);                      // тест сервопривода: ждём
  s1.write(90);                    // тест сервопривода: останавливаем
  delay(500);                      // ждём

  // запуск СОМ-порта
  Serial.begin(9600);
}

void loop() {
  RotDirMinMax_func();  // функция определения направления вращения, минимума, максимума освещения и их отношения

  if (SP_val < SP_MIN_VAL && PhR_ratio > MAXMINRATIO) {  // если панель недостаточно освещена и отношение макс/мин выше порогового (1.3)
    while (PhR_ratio > MAXMINSETRATIO) {                 // пока отношение больше порога (1.2)
      s1.write(90 + rotdir * SERVO_SPEED);               // вращаем сервопривод в направлении наиболее освещенного фоторезистора
      RotDirMinMax_func();                               // функция определения направления вращения, минимума, максимума освещения и их отношения
    }                                                    //
  } else s1.write(90);                                   // иначе сервопривод стоит

  Debug();             // отладка, если включена
  delay(GLOBALTIMER);  // ожидаем заданное время; в данном случае использование delay() вместо millis() допустимо, поскольку нет асинхронных действий
}

// функция определения направления вращения, минимума, максимума освещения и их отношения
void RotDirMinMax_func() {
  // считываем данные с датчиков
  SP_val = analogRead(SOLAR_PAN_PIN);                           // освещенность СП
  PhR1_val = map(analogRead(PHOTORES1_PIN), 0, 1023, 1023, 0);  // освещенность фоторезистора1
  PhR2_val = map(analogRead(PHOTORES2_PIN), 0, 1023, 1023, 0);  // освещенность фоторезистора2
  // определяем направление вращения СП в зависимости от освещенного фоторезистора и минимум-максимум значений на фоторезисторах
  if (PhR1_val > PhR2_val) {  // вариант 1:
    rotdir = -1;              // направление "-1"
    PhR_max = PhR1_val;       // макс
    PhR_min = PhR2_val;       // мин
  } else {                    // вариант 2:
    rotdir = 1;               // направление "+1"
    PhR_max = PhR2_val;       // макс
    PhR_min = PhR1_val;       // мин
  }
  // определяем, во сколько раз один фоторезистор освещеннее другого
  PhR_ratio = (float)PhR_max / PhR_min;
}

// вывод отладочной информации в СОМ-порт
void Debug() {
  if (DEBUG) {                                              // если включен
    Serial.print((String)0 + " " + (String)1023 + " || ");  // границы значений для плоттера

    // если один фоторезистор освещеннее другого - отображаем желаемое направление поворота
    if (PhR_ratio > MAXMINRATIO) {
      if (rotdir == 1) Serial.print("<<<<<  ");  // против часовой стрелки
      else Serial.print(">>>>>  ");              // по часовой стрелке
    } else Serial.print("|||||  ");              // не движется

    Serial.print((String)PhR_max + "/" + (String)PhR_min + "=" + (String)PhR_ratio + "   ");  // максимум делить на минимум равно отношение

    Serial.print((String)SP_val + "  ");    // освещенность солнечной панели
    Serial.print((String)PhR1_val + "  ");  // освещенность фоторезистора 1
    Serial.print((String)PhR2_val + "  ");  // освещенность фоторезистора 2
    Serial.println();                       // перевод строки
  }
}